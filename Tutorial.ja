# -*- rd -*-

= Tutorial.ja

$Id: Tutorial.ja 17 2004-09-14 06:47:53Z kou $

== はじめに

スタックを実現するプログラム（ライブラリ）をC言語で作成する。
プログラム作成はテストを作成しながら行う。テストの作成にはC
言語用のテスティングフレームワークであるCutterを用いる。

プログラムのビルドシステムにはGNUビルドシステム（GNU
Autoconf/GNU Automake/GNU Libtool）を使用する。GNUビルドシス
テムはビルド環境の差異を吸収する。これによりプログラム・テス
トを複数の環境で容易にビルドできるようになる。

大きなコストをかけずにプログラム本体が複数の環境で動作するの
であれば、その方がよい。さらにテストもその環境で動作するのな
らば、プログラム本体がその環境で正しく動作することを容易に検
証できる。プログラム本体だけではなく、テストも複数の環境で容
易に動作することは重要である。

Cutterが依存しているライブラリはGLibのみである。GLibはUNIX系
のシステムだけではなく、WindowsやMac OS X上でも動作する移植
性の高いライブラリである。CutterはGLibを利用することにより移
植性の高い状態を保ちつつ豊富なテスト支援機能を提供するxUnit
系のテスティングフレームワークである。

以下、スタックを作成しながらCutterの使い方について述べる。
なお、Cutterはインストールされているものとする。

このプログラムのソースコード一式はsample/stack/以下にある。

== ディレクトリ構成

まず、プログラムを作成するためのディレクトリを用意する。ディ
レクトリはstackとする。

  % mkdir -p ~/work/c/stack
  % cd stack

続いて、stack/ディレクトリ以下にビルド補助ファイル用ディレク
トリconfig/、プログラム用ディレクトリsrc/、テストプログラム用
ディレクトリtest/を作成する。

  [stack]% mkdir config src test

つまり、ディレクトリ構成は以下のようになる。

  stack/ -+- config/ ビルド補助用ディレクトリ
          |
          +- src/ ソースファイル用ディレクトリ
          |
          +- test/ テストプログラム用ディレクトリ

== GNUビルドシステム化

GNUビルドシステムでは、コマンドを実行し、いくつかのファイルを
自動生成する。これらのコマンドは、autogen.shというシェルスク
リプトを作成し、そこから呼び出すのが一般的である。ここでも、
その慣習に従う。

autogen.sh:
  #!/bin/sh

  run()
  {
      $@
      if test $? -ne 0; then
          echo "Failed $@"
          exit 1
      fi
  }

  run aclocal
  run libtoolize --copy --force
  run autoheader
  run automake --add-missing --foreign --copy
  run autoconf

autogen.shに実行権を付けることを忘れないこと。

  [stack]% chmod +x autogen.sh

run()はコマンドの実行結果を確認するための便利のための関数で
ある。実行しているコマンドはそれぞれ以下のためである。

  * aclocal: Automakeが利用するマクロをaclocal.m4に集める
  * libtoolize: libtoolを使用するために必要なファイルを用意
  * autoheader: configureスクリプトが利用するconfig.h.inファイルを作成
  * automake: configureスクリプトが利用するMakefile.inを生成
  * autoconf: configureスクリプトを生成

この時点でautogen.shを実行すると以下のようになる。

  [stack]% ./autogen.sh
  aclocal: `configure.ac' or `configure.in' is required
  Failed aclocal

Autoconf用のファイルであるconfigure.acを用意する必要がある。

=== configure.ac

autogen.shのための最低限のconfigure.acは以下の通りである。

configure.ac:
  AC_PREREQ(2.59)

  AC_INIT(stack, 0.0.1, you@example.com)
  AC_CONFIG_AUX_DIR([config])
  AC_CONFIG_HEADER([src/config.h])

  AM_INIT_AUTOMAKE($PACKAGE_NAME, $PACKAGE_VERSION)

  AC_PROG_LIBTOOL

  AC_CONFIG_FILES([Makefile])

  AC_OUTPUT

configure.acを用意してもう一度autogen.shを実行すると以下のよ
うになる。

  [stack]% ./autogen.sh
  Putting files in AC_CONFIG_AUX_DIR, `config'.
  configure.ac: installing `config/install-sh'
  configure.ac: installing `config/missing'
  automake: no `Makefile.am' found for any configure output
  Failed automake --add-missing --foreign --copy

今度はAutomakeのためにMakefile.amを用意する必要がある。

=== Makefile.am

autogen.shのためだけであれば空のMakefile.amで構わない。

  [stack]% touch Makefile.am
  [stack]% ./autogen.sh
  Putting files in AC_CONFIG_AUX_DIR, `config'.

これでconfigureスクリプトが生成される。この時点で一般的なソ
フトウェアのようにconfigure; make; make installができるよう
になる。

  [stack]% ./configure
  ...
  [stack]% make
  [stack]% make install

ただし、ビルドするものもインストールするものも何もないため、
今は何も起きない。

== はじめてのテスト作成

最低限のビルド環境が整ったので、テストの作成にはいる。まずは、
新しく作ったばかりのスタックは空であることをテストする。コー
ドにすると以下の通りである。

  void
  test_new_stack (void)
  {
      Stack *stack;
      stack = stack_new();
      if (stack_is_empty(stack))
          PASS;
      else
          FAIL;
  }

ここでは、上記のテストをCutterのテストとして動作させる。

=== テストプログラムの作成

テストプログラムはtest/以下に作成する。ここでは
test/test-stack.cとして作成するものとする。

まず、Cutterを使うためにcutter.hをincludeする。

test/test-stack.c:
  #include <cutter.h>

また、テスト対象のスタックの実装のAPIが書かれているstack.hも
includeする。（stack.hは後で作成する。）

test/test-stack.c:
  #include <stack.h>

続いて、このスタックのAPIを用いてテストを作成する。

test/test-stack.c:
  void
  test_new_stack (void)
  {
      Stack *stack;
      stack = stack_new();
      cut_assert(stack_is_empty(stack));
  }

cut_assert()は引数が0ならテストが失敗、0以外ならテストが成功
と判断するマクロである。Cutterのテストとはcut_XXX()マクロを使
用して、特定の状況で望んだ動作をしているかを検証するプログラ
ムを作成するということである。

以下に、「作成したばかりのスタックは空である」ということを検
証するテストのソースコード全体を示す。

test/test-stack.c:
  #include <cutter.h>
  #include <stack.h>

  void
  test_new_stack (void)
  {
      Stack *stack;
      stack = stack_new();
      cut_assert(stack_is_empty(stack));
  }

=== テストのビルド

Cutterの各テストは共有ライブラリになる。上記で作成したテスト
を共有ライブラリとしてビルドするために、Makefile.amを変更す
る。

==== test/以下でのビルド設定

現在のMakefile.amは空である。サブディレクトリであるtest/以下
のtest/test-stack.cをビルドするためにはMakefile.amにtest/以
下がサブディレクトリとして存在することを指定する。

Makefile.am:
  SUBDIRS = test

Makefile.amを変更した後にmakeを実行すると、makeがMakefile.am
の変更を検出し、Makefileなどを自動的に更新する。

  [stack]% % make
   cd . && /bin/sh /home/kou/work/c/cutter/sample/stack/config/missing --run automake-1.9 --foreign  Makefile
   cd . && /bin/sh ./config.status Makefile 
  config.status: creating Makefile
  Making all in test
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack/test' に入ります
  make[1]: *** ターゲット `all' を make するルールがありません.  中止.
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack/test' から出ます
  make: *** [all-recursive] エラー 1

test/以下もビルドしにいこうとしているのがわかる。ただし、
test/Makefileがないためtest/以下でのビルドは失敗している。

test/以下でビルドを行うようにするため、test/Makefile.amを作
成する。また、configureでtest/Makefileを生成するように指定す
る。

test/以下でのmakeが失敗しないようにするには、空の
test/Makefile.amでもよい。

  [stack]% touch test/Makefile.am

あとはconfigure.acにtest/Makefileを生成するように指定すれば
makeは通るようになる。

configure.ac:
  ...
  AC_CONFIG_FILES([Makefile
                   test/Makefile])
  ...

実際にmakeを実行すると自動で再びconfigureが走り、
test/Makefileが生成され、test/以下でのmakeが失敗しなくなる。

  [stack]% make
  ...
  config.status: creating test/Makefile
  config.status: creating src/config.h
  config.status: src/config.h is unchanged
  config.status: executing depfiles commands
  Making all in test
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack/test' に入ります
  make[1]: `all' に対して行うべき事はありません.
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack/test' から出ます
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack' に入ります
  make[1]: `all-am' に対して行うべき事はありません.
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack' から出ます

==== test/test_stack.soのビルド

それではtest/test_stack.cを共有ライブラリとしてビルドできる
ようにtest/Makefile.amを編集する。テスト用の共有ライブラリは
「test_」から始まる名前にする（「test_」の前に「lib」が付い
ても良い）。また、テストプログラムはインストールする必要がな
いため「noinst_」を使う。

test/Makefile.am:
  noinst_LTLIBRARIES = test_stack.la

テストの共有ライブラリはCutterが提供するテスト実行コマンド
cutterから動的に読み込まれる。動的に読み込まれる共有ライブラ
リは、libtoolに-moduleオプションを渡す必要がある。ま
た、-moduleオプションを指定する場合-rpathも指定する必要がある。
そこで、LDFLAGSを以下のように指定する。-avoid-versionはテスト
の共有ライブラリにはバージョン番号を付ける必要がないため指定
している。

test/Makefile.am:
  LDFLAGS = -module -rpath $(libdir) -avoid-version

test/test_stack.laのビルド（test_stack.soはtest/.libs/以下に
作成される）にはtest/test-stack.cを使用するので、それを指定す
る。

test/Makefile.am:
  test_stack_la_SOURCES = test-stack.c

これでtest/test_stack.laがビルドできる。

  [stack]% make
   cd . && /bin/sh /home/kou/work/c/cutter/sample/stack/config/missing --run automake-1.9 --foreign  Makefile
  Makefile.am: required file `config/depcomp' not found
  make: *** [Makefile.in] エラー 1

config/depcompを生成するには--add-missingオプション付きで
automakeを実行する必要がある。これにはautogen.shを使用できる。
また、configureを再実行する必要もある。

  [stack]% ./autogen.sh
  [stack]% ./configure

これでmakeを実行することによりtest/test_stack.laができるよう
になる。

  [stack]% make
  ...
  test-stack.c:1:20: error: cutter.h: No such file or directory
  test-stack.c:2:19: error: stack.h: No such file or directory
  test-stack.c: In function 'test_new_stack':
  test-stack.c:7: error: 'Stack' undeclared (first use in this function)
  test-stack.c:7: error: (Each undeclared identifier is reported only once
  test-stack.c:7: error: for each function it appears in.)
  test-stack.c:7: error: 'stack' undeclared (first use in this function)
  make[1]: *** [test-stack.lo] エラー 1
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack/test' から出ます
  make: *** [all-recursive] エラー 1

ただし、上記のようにCutterを使用する設定を行っていないため
cutter.hが読み込めない。また、スタックの実装もないため
stack.hの読み込みにも失敗する。

==== Cutterの使用

まずは、cutter.hを読み込めるようにする。Cutterは一般的なパッ
ケージ情報管理ツールpkg-configを使用している。そのため、容易
にGNUビルドシステムから利用することができる。

まず、configure.acにCutterを検出するコードを追加する。

configure.ac:
  ...
  PKG_CHECK_MODULES(CUTTER, cutter)
  AC_SUBST([CUTTER_CFLAGS])
  AC_SUBST([CUTTER_LIBS])

  AC_CONFIG_FILES([Makefile
                   test/Makefile])
  ...

また、test/Makefile.amでは検出したCutter用の設定を利用する。

test/Makefile.am:
  ...
  INCLUDES = $(CUTTER_CFLAGS)
  LIBS = $(CUTTER_LIBS)
  ...

現時点での完全なconfigure.acとtest/Makefile.amは以下のように
なる。

configure.ac:
  AC_PREREQ(2.59)

  AC_INIT(stack, 0.0.1, you@example.com)
  AC_CONFIG_AUX_DIR([config])
  AC_CONFIG_HEADER([src/config.h])

  AM_INIT_AUTOMAKE($PACKAGE_NAME, $PACKAGE_VERSION)

  AC_PROG_LIBTOOL

  PKG_CHECK_MODULES(CUTTER, cutter)
  AC_SUBST([CUTTER_CFLAGS])
  AC_SUBST([CUTTER_LIBS])

  AC_CONFIG_FILES([Makefile
                   test/Makefile])

  AC_OUTPUT

test/Makefile.am:
  noinst_LTLIBRARIES = test_stack.la

  INCLUDES = $(CUTTER_CFLAGS)
  LIBS = $(CUTTER_LIBS)

  LDFLAGS = -module -rpath $(libdir) -avoid-version

  test_stack_la_SOURCES = test-stack.c

変更後、makeを実行すると自動的にconfigureが実行され、Cutter
を利用したビルドが行われる。

  [stack]% make
  ...
  test-stack.c:2:19: error: stack.h: No such file or directory
  test-stack.c: In function 'test_new_stack':
  test-stack.c:7: error: 'Stack' undeclared (first use in this function)
  test-stack.c:7: error: (Each undeclared identifier is reported only once
  test-stack.c:7: error: for each function it appears in.)
  test-stack.c:7: error: 'stack' undeclared (first use in this function)
  make[1]: *** [test-stack.lo] エラー 1
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack/test' から出ます
  make: *** [all-recursive] エラー 1

cutter.hが読み込めないというエラーがなくなった。

==== スタックAPIの作成

次はstack.hが読み込めないエラーを解消する。

スタックの実装はsrc/以下に作成するので、スタックのAPIである
stack.hはsrc/stack.hに置く。

  [stack]% touch src/stack.h

インクルードパスを設定し、テストプログラムからstack.hを読み
込めるようにする。

test/Makefile.am:
  ...
  INCLUDES = $(CUTTER_CFLAGS) -I$(top_srcdir)/src
  ...

makeを実行するとstack.hが読み込めないエラーが解消されている
のが分かる。

  [stack]% make
  ...
  test-stack.c: In function 'test_new_stack':
  test-stack.c:7: error: 'Stack' undeclared (first use in this function)
  test-stack.c:7: error: (Each undeclared identifier is reported only once
  test-stack.c:7: error: for each function it appears in.)
  test-stack.c:7: error: 'stack' undeclared (first use in this function)
  make[1]: *** [test-stack.lo] エラー 1
  make[1]: ディレクトリ `/home/kou/work/c/cutter/sample/stack/test' から出ます
  make: *** [all-recursive] エラー 1

残りのエラーがStack型が宣言されていないことだけになった。

==== Stack型の宣言

src/stack.hにStack型を宣言し、テストプログラムをビルドできる
ようにする。

src/stack.h:
  #ifndef __STACK_H__
  #define __STACK_H__

  typedef struct _Stack Stack;

  #endif

stack_new()が宣言されていないため警告がでるが共有ライブラリ
を作成することはできる。

  [stack]% make
  ...
  test-stack.c: In function 'test_new_stack':
  test-stack.c:8: warning: assignment makes pointer from integer without a cast
  ...
  [stack]% file test/.libs/test_stack.so
  test/.libs/test_stack.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), not stripped

共有ライブラリが作成されたので、cutterコマンドでこのテストを
起動できる。

  [stack]% cutter test/
  cutter: symbol lookup error: test/.libs/test_stack.so: undefined symbol: stack_new

stack_new()が定義されていないため読み込みに失敗するが、テス
トプログラムが読み込まれることは確認できる。

==== テスト起動の自動化

GNUビルドシステムでは一般的にmake checkでテストが起動する。
スタックの実装でも同様にテストが起動するようにする。

まず、テストを起動するスクリプトtest/run-test.shを作成する。
cutterコマンドのパスは環境変数CUTTERで受け取ることにする。

test/run-test.sh:
  #!/bin/sh

  export BASE_DIR="`dirname $0`"
  $CUTTER --color=auto -s $BASE_DIR "$@" $BASE_DIR

実行権を付けることを忘れないこと。

  [stack]% chmod +x test/run-test.sh

test/Makefile.amにテスト起動スクリプトとしてtest/run-test.sh
を使うことを指定する。

test/Makefile.am:
  TESTS = run-test.sh
  TESTS_ENVIRONMENT = CUTTER="$(CUTTER)"
  ...

TESTS_ENVIRONMENTではcutterコマンドのパスを環境変数CUTTERで
渡している。cutterコマンドのパスはconfigureで検出する。
cutterコマンドのパスを検出するために、configure.acに以下を追
加する。

configure.ac:
  ...
  _PKG_CONFIG(CUTTER, variable=cutter, cutter)
  CUTTER=$pkg_cv_CUTTER
  AC_SUBST([CUTTER])
  ...

configure.ac全体は以下のようになる。

configure.ac:
  AC_PREREQ(2.59)

  AC_INIT(stack, 0.0.1, you@example.com)
  AC_CONFIG_AUX_DIR([config])
  AC_CONFIG_HEADER([src/config.h])

  AM_INIT_AUTOMAKE($PACKAGE_NAME, $PACKAGE_VERSION)

  AC_PROG_LIBTOOL

  PKG_CHECK_MODULES(CUTTER, cutter)
  AC_SUBST([CUTTER_CFLAGS])
  AC_SUBST([CUTTER_LIBS])

  _PKG_CONFIG(CUTTER, variable=cutter, cutter)
  CUTTER=$pkg_cv_CUTTER
  AC_SUBST([CUTTER])

  AC_CONFIG_FILES([Makefile
                   test/Makefile])

  AC_OUTPUT

make checkでテストが走ることを確認する。

  [stack]% make check
  ...
  cutter: symbol lookup error: ./.libs/test_stack.so: undefined symbol: stack_new
  FAIL: run-test.sh
  ================================
  1 of 1 tests failed
  Please report to you@example.com
  ================================
  ...

=== スタックの実装

*** ここまで ***

=== テスト起動の自動化

ディレクトリ構成が出来たので，次に，テストを起動を自動化する
ためのファイルを作成します．

まず，テスト起動用スクリプトcalc/test/run-test.shを作成しま
す．内容は以下のようにします．makeはGNU Makeを使うようにして
ください．システムによってはgmakeというコマンドでインストー
ルされているかもしれません．適宜変更してください．

  #!/bin/sh
  make test

実行権を付けるのを忘れないでください．

  [calc]% chmod +x test/run-test.sh

次に，calc/Makefileを作成します．内容は以下のようにします．

  include Makefile.test

calc/Makefile.testは「$PREFIX/share/cutter/Makefile.test」
（$PREFIXは./configure時に--prefixで指定した値）をコピーして
きます．あるいは，アーカイブ中のsample/calc/Makefile.testを
コピーしてもよいです．

ということで，現在は以下のような構成になっているはずです．

  calc/ -+- Makefile <- 作成
         |
         +- Makefile.test <- コピー
         |
         +- src/
         |
         +- test/ -+- run-test.sh <- 作成


== テストの作成

テストはtest/以下にtest_XXX.cという名前で作成します．今回は
test/test_calc.cとしてテストを書きましょう．

まず，足し算のテストを書きます．

  #include <cutter/cutter.h>
  
  #include "calc.h"
  
  UT_DEF(add_test)
  {
    UT_ASSERT_EQUAL_INT(3, add(1, 2), "1 + 2");
    UT_PASS;
  }
  
  UT_REGISTER_BEGIN("calc test")
  UT_REGISTER(add_test, "add test")
  UT_REGISTER_END

このテストでは，(({add(1, 2)}))の結果が(({3}))になるかをテス
トしています．それでは，run-test.elを使っている場合はC-cC-t
でテストを実行してみましょう．使っていない場合は以下のコマン
ドでテストを実行します．

  [calc]% test/run-test.sh

以下のような結果になるでしょう．

  Need to run make depend
  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG src/calc.c | sed -e 's,^\(.*\):,src/\1:,' > .depend.src
  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG test/test_calc.c | sed -e 's,^\(.*\):,test/\1:,' > .depend.test
  cat .depend.src .depend.test > .depend
  rm .depend.src .depend.test

これは，ファイル間の依存関係を自動計算しています．必要なとき
（今のようにファイルを作成したときや変更されたとき）に自動で
実行されます．

依存関係が計算されたのでもう一度C-cC-tでテストしてみましょう．

  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include` -o test/test_calc.o -c test/test_calc.c
  test/test_calc.c:3:18: calc.h: No such file or directory
  test/test_calc.c: In function `add_test':
  test/test_calc.c:7: warning: implicit declaration of function `add'
  gmake: *** [test/test_calc.o] エラー 1

calc.hがないのでコンパイルエラーになっています．ということで，
src/calc.hを作成しましょう．

  int add(int x, int y);

きっちりとこんな風にしてもよいです．

  #ifndef CALC_H
  #define CALC_H

  int add(int x, int y);

  #endif

それでは，C-cC-tでテストを走らせましょう．

  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include` -o test/test_calc.o -c test/test_calc.c
  gcc -L./ -shared -o test/libtest_calc.so test/test_calc.o
  cutter -vp
  dlopen() failed: ./test/libtest_calc.so: Undefined symbol "add"
  Assertion ((null)) failed load.c:43
  gmake: *** [do-test] Abort trap (コアダンプしました)
  rm test/test_calc.o

(({add}))が定義されていないのでcoreを吐いて終了しました．そ
れでは，src/calc.cに(({add}))の定義を書きましょう．テストで
は(({add})) は(({1})), (({2}))を引数として受け取ったら，
(({3}))を返すことになっていました．

  #include "calc.h"

  int
  add(int x, int y)
  {
    return 3;
  }

足し算していないと思うかもしれませんが，これでいいのです．テ
ストは(({3}))を返すことを期待しているのですから．

  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG src/calc.c | sed -e 's,^\(.*\):,src/\1:,' > .depend.src
  ...
  cutter -vp
  .
  [1/1](100.00%) tests passed.
  rm test/test_calc.o src/calc.o

コンパイル後にテストを実行（cutter -vp）しています．「tests
passed.」というのを見てもわかる通り，テストをパスしています．
予想通りですね．

ただ，今の(({add}))だと答えが3になる場合しか正しく動作しませ
ん．他の場合でも動作するようにテストを追加して，改良しましょ
う．

test/test_calc.cを以下のように変更します．

  UT_DEF(add_test)
  {
    UT_ASSERT_EQUAL_INT(3, add(1, 2), "1 + 2");
    UT_ASSERT_EQUAL_INT(1, add(3, -2), "3 + -2");
    UT_PASS;
  }

つまり，(({1 + 2}))の結果が(({3}))になるだけではなく，(({3 +
-2}))の結果が(({1}))になる必要があります．

それでは，C-cC-tでテストしましょう．

  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG src/calc.c | sed -e 's,^\(.*\):,src/\1:,' > .depend.src
  ...
  cutter -vp
  E
  Errors:
  ./test/test_calc.c:8: - calc test add test - 3 + -2
   expected: <1>
    but was: <3>

  [0/1](0.00%) tests passed.
  gmake: *** [do-test] エラー 1
  rm test/test_calc.o src/calc.o

予想通り失敗しました．(({3 + -2}))でも結果が3になっています．

それでは，テストをパスするようにsrc/calc.cをを変更しましょう．

  int
  add(int x, int y)
  {
    return x + y;
  }

C-cC-tでテストします．

  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG src/calc.c | sed -e 's,^\(.*\):,src/\1:,' > .depend.src
  ...
  cutter -vp
  .
  [1/1](100.00%) tests passed.
  rm test/test_calc.o src/calc.o

パスしました．あとは，今の手順を繰り返していけばよいです．つ
まり，こういうことです．

  * テストの作成
  * テストの実行（エラーになることを確認）
  * テストをパスするようにソースの変更
  * テストの実行（テストにパスすることを確認．パスするまでは
    次のテストを追加しない）

引き算，かけ算，割り算は宿題としましょう．

== おまけ

と思いましたが，引き算だけ追加してみましょう．自分でやりたい
人は見ないでください．

まず，test/test_calc.cにテストを追加します．

  UT_DEF(sub_test)
  {
    UT_ASSERT_EQUAL_INT(1, sub(3, 2), "3 - 2");
    UT_PASS;
  }

テストを登録することを忘れてはいけません．

  UT_REGISTER_BEGIN("calc test")
  UT_REGISTER(add_test, "add test")
  UT_REGISTER(sub_test, "sub test") /* <- 追加 */
  UT_REGISTER_END

C-cC-tでテストを実行します．

  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG src/calc.c | sed -e 's,^\(.*\):,src/\1:,' > .depend.src
  ...
  test/test_calc.c: In function `sub_test':
  test/test_calc.c:14: warning: implicit declaration of function `sub'
  cutter -vp
  dlopen() failed: ./test/libtest_calc.so: Undefined symbol "sub"
  Assertion ((null)) failed load.c:43
  gmake: *** [do-test] Abort trap (コアダンプしました)
  rm test/test_calc.o src/calc.o

(({sub}))を宣言をしていないことによる警告が出ています．また，
(({sub}))を定義していないためにcoreを吐いています．

まず，src/calc.hに(({sub}))のプロトタイプ宣言を追加しましょ
う．

  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG src/calc.c | sed -e 's,^\(.*\):,src/\1:,' > .depend.src
  ...
  cutter -vp
  dlopen() failed: ./test/libtest_calc.so: Undefined symbol "sub"
  Assertion ((null)) failed load.c:43
  gmake: *** [do-test] Abort trap (コアダンプしました)

(({sub}))の宣言がないという警告がなくなりました．

src/calc.cに定義を書きましょう．

  int
  sub(int x, int y)
  {
    return x - y;
  }

簡単ですね．

C-cC-tでテストしましょう．
  gcc -Wall -ggdb -Isrc -Itest -I`echo ~/local/include`   -MM -MG src/calc.c | sed -e 's,^\(.*\):,src/\1:,' > .depend.src
  ...
  cutter -vp
  ..
  [2/2](100.00%) tests passed.

パスしました．

以上です．かけ算と割り算は本当に宿題です．


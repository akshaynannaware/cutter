# -*- rd -*-

= Tutorial --- How to use Cutter

== Introduction

We write a program (library) that implements a stack in C.
We write a program with writing tests. To write tests, we
use Cutter that is an unit testing framework for C.

We use GNU build system (GNU Autoconf/GNU Automake/GNU
Libtool) for build system. GNU build system lessens
disparities on build environment. For this reason, we can
build our program and tests on several environment easily.

It's better that a program works on several environment
without many costs. If tests of the program works on the
environment too, we can verify the program works well on the
environment easily. It's important that both a program and
tests are works well on several environment easily.

Cutter requires only GLib. GLib is a very portable library
that works on not only UNIX-like system but also Windows and
Mac OS X. Cutter provides many useful test support features
with portability due to GLib. Cutter is a testing framework
and respects to xUnit style.

We will learn how to use Cutter with writing a stack
implementation. We assume that Cutter is already installed
into your system.

There are source codes of this program in sample/stack/.

== Directory hierarchy

First, we need to setup a directory for our stack
program. We use 'stack' as the directory name.

  % mkdir -p /tmp/stack
  % cd /tmp/stack

Next, we make some directories: config/ that is for build
auxiliary files, src/ that is for our source files and test/
that is for tests.

  [stack]% mkdir config src test

After the above, we get the following directory hierarchy:

  stack/ -+- config/ for build auxiliary files
          |
          +- src/ for source files
          |
          +- test/ for tests

== Use GNU build system

In GNU build system start-up, some commands are ran and they
generates some files automatically. They usually are run
from an authgen.sh shell script. We follow the convention.

autogen.sh:
  #!/bin/sh

  run()
  {
      $@
      if test $? -ne 0; then
          echo "Failed $@"
          exit 1
      fi
  }

  run aclocal
  run libtoolize --copy --force
  run autoheader
  run automake --add-missing --foreign --copy
  run autoconf

Don't forget to make the autogen.sh executable.

  [stack]% chmod +x autogen.sh

run() is a convenience function to confirm a result of ran
command. The following list shows what is done by them:

  * aclocal: collects macros that is used by Automake into aclocal.m4.
  * libtoolize: prepares files that is needed by libtool.
  * autoheader: generates config.h.in that is used by
    configure script.
  * automake: generates Makefile.in that is used by
    configure script.
  * autoconf: generates configure scripts.

The following is a result of autogen.sh at this point:

  [stack]% ./autogen.sh
  aclocal: `configure.ac' or `configure.in' is required
  Failed aclocal

We need to prepare configure.ac that is for Autoconf.

=== configure.ac

The following is a minimum configure.ac for our autogen.sh.

configure.ac:
  AC_PREREQ(2.59)

  AC_INIT(stack, 0.0.1, you@example.com)
  AC_CONFIG_AUX_DIR([config])
  AC_CONFIG_HEADER([src/config.h])

  AM_INIT_AUTOMAKE($PACKAGE_NAME, $PACKAGE_VERSION)

  AC_PROG_LIBTOOL

  AC_CONFIG_FILES([Makefile])

  AC_OUTPUT

The following is a result of autogen after preparing
configure.ac.

  [stack]% ./autogen.sh
  Putting files in AC_CONFIG_AUX_DIR, `config'.
  configure.ac: installing `config/install-sh'
  configure.ac: installing `config/missing'
  automake: no `Makefile.am' found for any configure output
  Failed automake --add-missing --foreign --copy

We need to prepare Makefile.am for Automake.

=== Makefile.am

An empty Makefile.am is enough if the Makefile.am is just
only for autogen.sh.

  [stack]% touch Makefile.am
  [stack]% ./autogen.sh
  Putting files in AC_CONFIG_AUX_DIR, `config'.

A configure script can be generated. We can do 'configure;
make; make install' like many popular softwares at this
point:

  [stack]% ./configure
  ...
  [stack]% make
  [stack]% make install

But for now, nothing is to happen because we doesn't have
any items that are needed to build or install.

== First test writing

We can write a test because we got a minimal build
environment. First, we test that a newly created statck
should be empty. The following code representes this test in
C:

  void
  test_new_stack (void)
  {
      Stack *stack;
      stack = stack_new();
      if (stack_is_empty(stack))
          PASS;
      else
          FAIL;
  }

We change this test code to be able to run as a test code
for Cutter.

=== Write a test program

A test program is put into test/. In this tutorial, we make
a test program as test/test-stack.c.

First, we need to include cutter.h to use Cutter.

test/test-stack.c:
  #include <cutter.h>

And we need to include stack.h that declares API for test target
stack implementation. (stack.h will be made later.)

test/test-stack.c:
  #include <stack.h>

Next, we write a test with the stack API:

test/test-stack.c:
  void test_new_stack (void);

  void
  test_new_stack (void)
  {
      Stack *stack;
      stack = stack_new();
      cut_assert(stack_is_empty(stack));
  }

cut_assert() is a macro that fails if the first argument is
0, passes otherwise. Writing tests with Cutter means that
writing a program that verifies a target program works as
we expected at the specific situation.

The following test code is a whole test code to test "a
newly created stack should be empty".

test/test-stack.c:
  #include <cutter.h>
  #include <stack.h>

  void test_new_stack (void);

  void
  test_new_stack (void)
  {
      Stack *stack;
      stack = stack_new();
      cut_assert(stack_is_empty(stack));
  }

=== Build a test

Each test programs for Cutter are shared libraries. To build
the above test program as shared library, we change
Makefile.am.

==== Build configuration in test/

Makefile.am is empty for now. To build test/test-stack.c in
test/ directory, we need to specify that there is test/
directory as sub directory in Makefile.am.

Makefile.am:
  SUBDIRS = test

make will detect Makefile.am is changed and update Makefile
and so on automatically after we change Makefile.am and run
make.

  [stack]% make
   cd . && /bin/sh /tmp/stack/config/missing --run automake-1.9 --foreign  Makefile
   cd . && /bin/sh ./config.status Makefile 
  config.status: creating Makefile
  Making all in test
  config.status: creating Makefile
  Making all in test
  make[1]: Entering directory `/tmp/stack/test'
  make[1]: *** No rule to make target `all'.  Stop.
  make[1]: Leaving directory `/tmp/stack/test'
  make: *** [all-recursive] Error 1

We find that make go down to test/ to build. But make is
failed in test/ because test/Makefile doesn't exist.

To build in test/, we will make test/Makefile.am and indicate
configure.ac to generate test/Makefile.

An empty test/Makefile.am is OK for just protecting make
failure in test/.

  [stack]% touch test/Makefile.am

Next, we indicate configure.ac to generate
test/Makefile. Now, make will be done successfully.

configure.ac:
  ...
  AC_CONFIG_FILES([Makefile
                   test/Makefile])
  ...

If we run make again, make re-runs configure and
test/Makefile is generated. Now make doesn't fail in test/.

  [stack]% make
  ...
  config.status: creating Makefile
  config.status: creating test/Makefile
  config.status: creating src/config.h
  config.status: src/config.h is unchanged
  config.status: executing depfiles commands
  Making all in test
  make[1]: Entering directory `/tmp/stack/test'
  make[1]: Nothing to be done for `all'.
  make[1]: Leaving directory `/tmp/stack/test'
  make[1]: Entering directory `/tmp/stack'
  make[1]: Nothing to be done for `all-am'.
  make[1]: Leaving directory `/tmp/stack'

==== Build test/test_stack.so

We will edit test/Makefile.am to build test/test-stack.c as
a shared library. A shared library for test should be named
as "test_" prefix. (It's OK if "lib" is prepended to "test_"
prefix.) We use "noinst_" because a test program isn't
needed to be installed.

test/Makefile.am:
  noinst_LTLIBRARIES = test_stack.la

Shared libraries for test are loaded dynamically by cutter
that is a command included in Cutter to run test. Shared
libraries that are loaded dynamically should be builded
libtool with -module option. -rpath option is also required
by -module option. Because of them LDFLAGS becomes the
following. The reason why -avoid-version is specified is
that shared libraries for test aren't needed to have version
number.

test/Makefile.am:
  LDFLAGS = -module -rpath $(libdir) -avoid-version

To build test/test_stack.la, test/test-stack.c is
used. (test_stack.so is generated into test/.libs/.) We need
to specify this.

test/Makefile.am:
  test_stack_la_SOURCES = test-stack.c

Now, we can build test/test_stack.la.

  [stack]% make
  ...
   cd .. && /bin/sh /tmp/stack/config/missing --run automake-1.10 --foreign  test/Makefile
  test/Makefile.am: required file `config/depcomp' not found
  test/Makefile.am:   `automake --add-missing' can install `depcomp'
  make[1]: *** [Makefile.in] Error 1
  make[1]: Leaving directory `/tmp/stack/test'
  make: *** [all-recursive] Error 1

To generate config/depcomp, we need to run automake with
--add-missing option. To do this, we can use
autogen.sh. Don't forget to re-run configure.

  [stack]% ./autogen.sh
  [stack]% ./configure

Now, we can build test/test_stack.la with make.

  [stack]% make
  ...
  test-stack.c:1:20: error: cutter.h: No such file or directory
  test-stack.c:2:19: error: stack.h: No such file or directory
  test-stack.c: In function 'test_new_stack':
  test-stack.c:9: error: 'Stack' undeclared (first use in this function)
  test-stack.c:9: error: (Each undeclared identifier is reported only once
  test-stack.c:9: error: for each function it appears in.)
  test-stack.c:9: error: 'stack' undeclared (first use in this function)
  make[1]: *** [test-stack.lo] Error 1
  make[1]: Leaving directory `/tmp/stack/test'
  make: *** [all-recursive] Error 1

But there are the above errors because we don't setup to use
Cutter yet. And we can't include stack.h because we don't
have a stack implementation yet.

==== Use Cutter

We will support cutter.h including. Cutter uses pkg-config
that is a popular package information management
tool. Because of this, we can use Cutter with GNU build
system.

First, we add a code to detect Cutter into configure.ac.

configure.ac:
  ...
  PKG_CHECK_MODULES(CUTTER, cutter)
  AC_SUBST([CUTTER_CFLAGS])
  AC_SUBST([CUTTER_LIBS])

  AC_CONFIG_FILES([Makefile
                   test/Makefile])
  ...

We use detected Cutter information in test/Makefile.am:

test/Makefile.am:
  ...
  INCLUDES = $(CUTTER_CFLAGS)
  LIBS = $(CUTTER_LIBS)
  ...

The followings are the current whole configure.ac and test/Makefile.am:

configure.ac:
  AC_PREREQ(2.59)

  AC_INIT(stack, 0.0.1, you@example.com)
  AC_CONFIG_AUX_DIR([config])
  AC_CONFIG_HEADER([src/config.h])

  AM_INIT_AUTOMAKE($PACKAGE_NAME, $PACKAGE_VERSION)

  AC_PROG_LIBTOOL

  PKG_CHECK_MODULES(CUTTER, cutter)
  AC_SUBST([CUTTER_CFLAGS])
  AC_SUBST([CUTTER_LIBS])

  AC_CONFIG_FILES([Makefile
                   test/Makefile])

  AC_OUTPUT

test/Makefile.am:
  noinst_LTLIBRARIES = test_stack.la

  INCLUDES = $(CUTTER_CFLAGS)
  LIBS = $(CUTTER_LIBS)

  LDFLAGS = -module -rpath $(libdir) -avoid-version

  test_stack_la_SOURCES = test-stack.c

We run make again and make runs configure automatically and
builds with Cutter configuration after the above changes.

  [stack]% make
  ...
  test-stack.c:2:19: error: stack.h: No such file or directory
  test-stack.c: In function 'test_new_stack':
  test-stack.c:9: error: 'Stack' undeclared (first use in this function)
  test-stack.c:9: error: (Each undeclared identifier is reported only once
  test-stack.c:9: error: for each function it appears in.)
  test-stack.c:9: error: 'stack' undeclared (first use in this function)
  make[1]: *** [test-stack.lo] Error 1
  make[1]: Leaving directory `/tmp/stack/test'
  make: *** [all-recursive] Error 1

An error that reports "cutter.h can't be included" is gone away.

==== Make stack API

We will fix an error that stack.h can't be included.

We put stack.h into src/stack.h because we make a stack
implementation in src/.

  [stack]% touch src/stack.h

To include stack.h from test program, we configure include
path:

test/Makefile.am:
  ...
  INCLUDES = $(CUTTER_CFLAGS) -I$(top_srcdir)/src
  ...

We will find that an error that stack.h can't be included is
gone away if we run make again.

  [stack]% make
  ...
  test-stack.c: In function 'test_new_stack':
  test-stack.c:9: error: 'Stack' undeclared (first use in this function)
  test-stack.c:9: error: (Each undeclared identifier is reported only once
  test-stack.c:9: error: for each function it appears in.)
  test-stack.c:9: error: 'stack' undeclared (first use in this function)
  make[1]: *** [test-stack.lo] Error 1
  make[1]: Leaving directory `/tmp/stack/test'
  make: *** [all-recursive] Error 1

There is only an error that Stack type isn't declared.

==== Declare Stack type

To build our test program, we declare Stack type in src/stack.h.

src/stack.h:
  #ifndef __STACK_H__
  #define __STACK_H__

  typedef struct _Stack Stack;

  #endif

We get a warning because stack_new() isn't declared but we
can build a shared library.

  [stack]% make
  ...
  test-stack.c: In function 'test_new_stack':
  test-stack.c:10: warning: assignment makes pointer from integer without a cast
  ...
  [stack]% file test/.libs/test_stack.so
  test/.libs/test_stack.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), not stripped

==== Declare stack_new()/stack_is_empty()

To suppress a warning, we declare stack_new() and stack_is_empty().

src/stack.h:
  ...
  Stack *stack_new      (void);
  int    stack_is_empty (Stack *stack);
  ...

We can confirm that make don't report any warnings now.

  [stack]% make

=== Run test

Now, we can run a test because we got a shared library.

  [stack]% cutter test/
  cutter: symbol lookup error: test/.libs/test_stack.so: undefined symbol: stack_new

Loading our test is failed due to undefined stack_new() but
we can confirm that our test is loaded.

==== Automate running test

GNU build system use 'make check' to run test. We follow
the convention in our stack implementation.

First, we make a script test/run-test.sh that runs our
test. A path of cutter command is passed from environment
variable CUTTER.

test/run-test.sh:
  #!/bin/sh

  export BASE_DIR="`dirname $0`"
  $CUTTER --color=auto -s $BASE_DIR "$@" $BASE_DIR

Don't forget to make the test/run-test.sh executable.

  [stack]% chmod +x test/run-test.sh

We need to specify that we use test/run-test.sh as a test
runner script to test/Makefile.am.

test/Makefile.am:
  TESTS = run-test.sh
  TESTS_ENVIRONMENT = CUTTER="$(CUTTER)"
  ...

We pass a path of cutter command via environment variable
CUTTER in TESTS_ENVIRONMENT. A path of cutter command is
detected by configure. The following code is for detecting a
path of cutter command.

configure.ac:
  ...
  _PKG_CONFIG(CUTTER, variable=cutter, cutter)
  CUTTER=$pkg_cv_CUTTER
  AC_SUBST([CUTTER])
  ...

The following is the whole of configure.ac.

configure.ac:
  AC_PREREQ(2.59)

  AC_INIT(stack, 0.0.1, you@example.com)
  AC_CONFIG_AUX_DIR([config])
  AC_CONFIG_HEADER([src/config.h])

  AM_INIT_AUTOMAKE($PACKAGE_NAME, $PACKAGE_VERSION)

  AC_PROG_LIBTOOL

  PKG_CHECK_MODULES(CUTTER, cutter)
  AC_SUBST([CUTTER_CFLAGS])
  AC_SUBST([CUTTER_LIBS])

  _PKG_CONFIG(CUTTER, variable=cutter, cutter)
  CUTTER=$pkg_cv_CUTTER
  AC_SUBST([CUTTER])

  AC_CONFIG_FILES([Makefile
                   test/Makefile])

  AC_OUTPUT

We can confirm that 'make check' runs our test.

  [stack]% make check
  ...
  cutter: symbol lookup error: ./.libs/test_stack.so: undefined symbol: stack_new
  FAIL: run-test.sh
  ================================
  1 of 1 tests failed
  Please report to you@example.com
  ================================
  ...

==== Make test/run-test.sh workable alone

In 'make check', there are outputs that isn't test result
like build logs. They hid test result that is interested by
us. So we want test/run-test.sh to work without invoking
from 'make check'.

test/run-test.sh needs to detect a path of cutter command
automatically if environment variable CUTTER isn't set. And
test/run-test.sh needs to run make to rebuild necessary
files if test/run-test.sh isn't invoked from 'make check'.

test/run-test.sh:
  #!/bin/sh

  export BASE_DIR="`dirname $0`"

  if test -z "$NO_MAKE"; then
      make -C $BASE_DIR/../ > /dev/null || exit 1
  fi

  if test -z "$CUTTER"; then
      CUTTER="`make -s -C $BASE_DIR echo-cutter`"
  fi

  $CUTTER --color=auto -s $BASE_DIR "$@" $BASE_DIR

To support the test/run-test.sh, test/Makefile.am has some
works.

test/Makefile.am:
  ...
  TESTS_ENVIRONMENT = NO_MAKE=yes CUTTER="$(CUTTER)"
  ...
  echo-cutter:
  	@echo $(CUTTER)

The following is the whole of test/Makefile.am.

test/Makefile.am:
  TESTS = run-test.sh
  TESTS_ENVIRONMENT = NO_MAKE=yes CUTTER="$(CUTTER)"

  noinst_LTLIBRARIES = test_stack.la

  INCLUDES = $(CUTTER_CFLAGS) -I$(top_srcdir)/src
  LIBS = $(CUTTER_LIBS)

  LDFLAGS = -module -rpath $(libdir) -avoid-version

  test_stack_la_SOURCES = test-stack.c

  echo-cutter:
  	@echo $(CUTTER)

We can confirm that test/run-test.sh runs test even if it's not
invoked from 'make check'.

  [stack]% test/run-test.sh
  cutter: symbol lookup error: test/.libs/test_stack.so: undefined symbol: stack_new

We will use test/run-test.sh instead of 'make check' from
now. Test result that is what we are interested
in will not be hid because test/run-test.sh just outputs
build errors and/or warnings and test result.

We spent some times to build testing environment before we
implement stack. It reduces costs to run test. If costs to
run test isn't low, we will not run test gradually. It
may cause quality loss.

Building testing environment at first delays start time of
implementing a main program. But we need to keep quality of
a main program by running test until a main program is
developed and maintained. We will be able to collect costs
that is spent for building testing environment. It's
important that building testing environment at first to
be developing a high-quality program comfortably.

=== スタックの実装

テスト環境の整備ができたため、スタックの実装に入る。

==== 簡単なstack_new()の実装

まず、stack_new()を定義し、実行時エラーの原因を解決する。

スタックの実装はsrc/stack.cで行う。簡単なstack_new()の実装は
以下の通りである。

src/stack.c:
  #include <stdlib.h>
  #include "stack.h"

  Stack *
  stack_new (void)
  {
      return NULL;
  }

==== src/libstack.laのビルド

それでは、makeでsrc/stack.cをビルドできるようにする。

まず、test/以下をビルド対象に加えたように、src/以下もビルド
対象とする。

Makefile.am:
  SUBDIRS = src test

configure.ac:
  ...
  AC_CONFIG_FILES([Makefile
                   src/Makefile
                   test/Makefile])
  ...

これでsrc/以下もビルド対象となる。

  [stack]% test/run-test.sh
  configure.ac:19: required file `src/Makefile.in' not found
  make: *** [Makefile.in] エラー 1

src/Makefile.amを作成するとこのエラーはなくなる。

  [stack]% touch src/Makefile.am
  [stack]% test/run-test.sh
  cutter: symbol lookup error: test/.libs/test_stack.so: undefined symbol: stack_new

makeは通るようになるが、この時点ではsrc/stack.cはビルドされ
ないし、テストプログラムもlibstack.soをリンクしていないので
stack_new()が定義されていないエラーは変わらない。

src/Makefile.amに以下を追加し、src/stack.cからlibstack.soを
作成する。

src/Makefile.am:
  lib_LTLIBRARIES = libstack.la

  libstack_la_SOURCES = stack.c

makeでsrc/.libs/libstack.so.0.0.0を生成することができる。

  [stack]% make
  [stack]% file src/.libs/libstack.so.0.0.0
  src/.libs/libstack.so.0.0.0: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), not stripped

==== src/libstack.laのリンク

libstack.soはできたがテストプログラムにはリンクしていないの
で、まだ実行時エラーは発生する。

  [stack]% test/run-test.sh
  cutter: symbol lookup error: test/.libs/test_stack.so: undefined symbol: stack_new

libstack.soをリンクするためにtest/Makefile.amを以下のように
変更する。

test/Makefile.am:
  ...
  LIBS = $(CUTTER_LIBS) $(top_builddir)/src/libstack.la
  ...

テストプログラムを再リンクする必要があるため、一度make clean
してからビルドしなおす。

  [stack]% make clean
  [stack]% make
  [stack]% test/run-test.sh
  cutter: symbol lookup error: test/.libs/test_stack.so: undefined symbol: stack_is_empty

今まではstack_new()が見つからずにエラーが発生していたが、
stack_is_empty()が見つからないというエラーに変わった。これに
より、libstack.soがリンクされていることが確認できた。

==== stack_is_empty()の実装

テストプログラム中ではstack_is_empty()の結果を以下のようにテ
ストしている。

test/test-stack.c:
  ...
  cut_assert(stack_is_empty(stack));
  ...

つまり、stack_is_empty()が真を返すことをテストしている。よっ
て、src/stack.cでのstack_is_empty()は真を返す必要がある。

src/stack.c:
  ...
  #define TRUE 1
  #define FALSE 0
  ...
  int
  stack_is_empty (Stack *stack)
  {
      return TRUE;
  }

src/stack.c全体は以下のようになる。

src/stack.c:
  #include <stdlib.h>
  #include "stack.h"

  #define TRUE 1
  #define FALSE 0

  Stack *
  stack_new (void)
  {
      return NULL;
  }

  int
  stack_is_empty (Stack *stack)
  {
      return TRUE;
  }


このstack_is_empty()の実装は常に真を返すため、テストは成功す
るはずである。

  [stack]% test/run-test.sh
  .

  Finished in 0.000006 seconds

  1 test(s), 1 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

「.」がひとつ表示されているのは1つのテストがパスしたことを表
している。現在は1つしかテストがないので1つのテストにパスした
ということはすべてのテストにパスしたということである。

環境によっては表示が緑になっているはずである。これはテストが
パスしているので次に進んでもよいという意味である。

テストが動作することが確認できたので、以降ではテストを作成し
ながらスタックの実装を完成させる。

== pushの実装

まずはpushを実装する。今回の実装では、スタックにはintのみを
格納できることする。

=== pushのテスト

pushをした後はスタックのサイズが1になり、スタックは空ではなく
なるはずである。これをテストにすると以下のようになる。

test/test-stack.c:
  ...
  void test_push (void);
  ...
  void
  test_push (void)
  {
      Stack *stack;

      stack = stack_new();
      cut_assert_equal_int(0, stack_get_size(stack));
      stack_push(stack, 100);
      cut_assert_equal_int(1, stack_get_size(stack));
      cut_assert(!stack_is_empty(stack));
  }

テストを実行すると、stack_get_size()が定義されていないため実
行時エラーになる。

  [stack]% test/run-test.sh
  cutter: symbol lookup error: ./test/.libs/test_stack.so: undefined symbol: stack_get_size

このテストをパスするようにpushを実装する。

=== cut_stack_push()の実装

まずは、パスしなくても良いのでテストが動くように
stack_get_size()とstack_push()を実装する。

まず、src/stack.hに宣言を追加する。

src/stack.h:
  ...
  int    stack_get_size (Stack *stack);
  void   stack_push     (Stack *stack, int value);
  ...

続いてsrc/stack.cに定義を追加する。

src/stack.c:
  ...
  int
  stack_get_size (Stack *stack)
  {
      return 0;
  }

  void
  stack_push (Stack *stack, int value)
  {
  }

stack_get_size()が0を返しているのは、最初のstack_get_size()
は以下のように0を期待されているからである。

test/test-stack.c:
  ...
  stack = stack_new();
  cut_assert_equal_int(0, stack_get_size(stack));
  ...

pushの実装ができたのでテストを実行する。

  [stack]% test/run-test.sh
  F.

  1) Failure: test_push
  <1 == stack_get_size(stack)>
  expected: <1>
   but was: <0>
  ./test/test-stack.c:23: test_push()

  Finished in 0.000086 seconds

  2 test(s), 2 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

「F」はテストが失敗（Failure）したことを表している。環境によっ
ては表示が赤くなっているはずである。これは、テストがパスして
いないので先に進むことは危険であることを示している。popの実
装に移る前にテストをパスさせるようにpushを実装を改良するべき
だということである。

cutterからのメッセージでは、test/test-stack.cの24行目、
test_push()関数の中でstack_get_size(stack)の値が1ではなく0の
ために失敗したということを表している。該当する行は以下の通り
である。

test/test-stack.c:23:
  cut_assert_equal_int(1, stack_get_size(stack));

これはstack_get_size()が常に0を返しているためである。
stack_push()された後には内部のカウンタを1つ進める必要がある。

=== メモリ開放

今まではstack_new()でNULLを返していたが、test_pushテストをパ
スするためには内部にカウンタを持つ必要があるため、メモリを割
り当てる必要がある。メモリを割り当てた場合、使用済のメモリを
開放する必要がある。

例えば、test_new_stack()では以下のようにする必要がある。

  void
  test_new_stack (void)
  {
      Stack *stack;
      stack = stack_new();
      cut_assert(stack_is_empty(stack));
      stack_free(stack);
  }

しかし、stack_free()の前のcut_assert()が失敗した場合はその時
点で処理が終了してしまうため、stack_free()が呼ばれずメモリリー
クが発生する。（ただし、テストプログラムはすぐに終了する短命
なプログラムため、害が大きくなることは少ない。）

Cutterではテストの前後に必ず実行される関数を設定することがで
きる。それがsetup()/teardown()である。これらはテストが成功し
た場合も失敗した場合も呼ばれるためテスト中で割り当てたメモリ
を確実に開放する処理などに使うことができる。

test_new_stack()をsetup()/teardown()を使って確実にメモリを開
放するようにすると以下のようになる。

test/test-stack.c:
  ...
  static Stack *stack;

  void
  setup (void)
  {
      stack = NULL;
  }

  void
  teardown (void)
  {
      if (stack)
          stack_free(stack);
  }

  void
  test_new_stack (void)
  {
      stack = stack_new();
      cut_assert(stack_is_empty(stack));
  }
  ...

同様に、test_push()でも、関数内のローカル変数stackを使わずに
ファイル中でstaticなstackを使用すれば確実にメモリを開放でき
る。

test/test-stack.c:
  ...
  void
  test_push (void)
  {
      stack = stack_new();
      cut_assert_equal_int(0, stack_get_size(stack));
      stack_push(stack, 100);
      cut_assert_equal_int(1, stack_get_size(stack));
      cut_assert(!stack_is_empty(stack));
  }
  ...

setup()/teardown()を使用したtest/test-stack.c全体は以下のよ
うになる。

test/test-stack.c:
  #include <cutter.h>
  #include <stack.h>

  void test_new_stack (void);
  void test_push (void);

  static Stack *stack;

  void
  setup (void)
  {
      stack = NULL;
  }

  void
  teardown (void)
  {
      if (stack)
          stack_free(stack);
  }

  void
  test_new_stack (void)
  {
      stack = stack_new();
      cut_assert(stack_is_empty(stack));
  }

  void
  test_push (void)
  {
      stack = stack_new();
      cut_assert_equal_int(0, stack_get_size(stack));
      stack_push(stack, 100);
      cut_assert_equal_int(1, stack_get_size(stack));
      cut_assert(!stack_is_empty(stack));
  }

この変更の後でもテストが変更前と同じ結果を返すことを確認する。

  [stack]% test/run-test.sh
  F.

  1) Failure: test_push
  <1 == stack_get_size(stack)>
  expected: <1>
   but was: <0>
  test/test-stack.c:34: test_push()

  Finished in 0.000092 seconds

  2 test(s), 2 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

=== stack_new()/stack_free()の実装

それでは、stack_new()でメモリを割り当て、stack_free()で開放
する処理を実装する。

まず、src/stack.hにstack_free()を宣言する。

src/stack.h:
  ...
  void   stack_free     (Stack *stack);
  ...

続いて、src/stack.cにStackを定義する。Stackはスタックのサイズ
を保存するフィールドを含む。

src/stack.c:
  ...
  struct _Stack {
      int size;
  };
  ...

stack_new()でStackのためのメモリを割り当て、stack_free()で開
放する。

src/stack.c:
  ...
  Stack *
  stack_new (void)
  {
      Stack *stack;

      stack = malloc(sizeof(Stack));
      if (!stack)
          return NULL;

      stack->size = 0;
      return stack;
  }

  void
  stack_free (Stack *stack)
  {
      free(stack);
  }
  ...

この変更の後でもテストが変更前と同じ結果を返すことを確認する。

  [stack]% test/run-test.sh
  F.

  1) Failure: test_push
  <1 == stack_get_size(stack)>
  expected: <1>
   but was: <0>
  test/test-stack.c:34: test_push()

  Finished in 0.000090 seconds

  2 test(s), 2 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

=== stack_push()の本実装

Stackにスタックサイズを持つことができるようになったので、こ
れを使用してテストをパスするように
stack_push()/stack_get_size()を実装する。

src/stack.c:
  ...
  int
  stack_get_size (Stack *stack)
  {
      return stack->size;
  }

  void
  stack_push (Stack *stack, int value)
  {
      stack->size++;
  }

pushする毎にスタックサイズを増やし、そのサイズを返すようにし
た。これで今まで失敗していたstack_get_size()のテストがパスす
るはずである。

  [stack]% test/run-test.sh
  F.

  1) Failure: test_push
  expected: <!stack_is_empty(stack)> is not TRUE/NULL
  ./test/test-stack.c:35: test_push()

  Finished in 0.000087 seconds

  2 test(s), 3 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

期待通りstack_get_size()のテストはパスしたがその後の
test/test-stack.cの35行目、stack_is_empty()で失敗している。

test/test-stack.c:35:
  cut_assert(!stack_is_empty(stack));

スタックにpushしたら空ではなくなるはずである。

=== stack_is_empty()の本実装

スタックが空なのはスタックサイズが0のときである。よって、
stack_is_empty()の実装は以下のようになる。

src/stack.c:
  ...
  int
  stack_is_empty (Stack *stack)
  {
      return stack->size == 0;
  }
  ...

テストを実行し、すべてのテストにパスすることを確認する。

  % test/run-test.sh
  ..

  Finished in 0.000015 seconds

  2 test(s), 4 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

pushのテストもパスし、既存のスタックを作った直後の場合のテス
トもパスしたままである。すべてのテストがパスしたため、結果表
示も緑に戻った。これで安心してpopの実装に進むことができる。

== popの実装

pushが実装できたので、次はpushで入れたデータを取り出すpopを
実装する。

=== popのテスト

popをすると最後にpushした値が順番に返ってくる。また、popする
毎にスタックサイズが減り、最後は空になる。これをテストにする
と以下のようになる。

test/test-stack.c:
  ...
  void
  test_pop (void)
  {
      stack = stack_new();

      stack_push(stack, 10);
      stack_push(stack, 20);
      stack_push(stack, 30);

      cut_assert_equal_int(3, stack_get_size(stack));
      cut_assert_equal_int(30, stack_pop(stack));
      cut_assert_equal_int(2, stack_get_size(stack));
      cut_assert_equal_int(20, stack_pop(stack));
      cut_assert_equal_int(1, stack_get_size(stack));

      stack_push(stack, 40);
      cut_assert_equal_int(2, stack_get_size(stack));
      cut_assert_equal_int(40, stack_pop(stack));
      cut_assert_equal_int(1, stack_get_size(stack));
      cut_assert_equal_int(10, stack_pop(stack));
      cut_assert_equal_int(0, stack_get_size(stack));
      cut_assert(stack_is_empty(stack));
  }

テストを走らせる。

  [stack]% test/run-test.sh
  ..cutter: symbol lookup error: test/.libs/test_stack.so: undefined symbol: stack_pop

stack_pop()を定義していないためエラーが発生している。エラー
メッセージの前に「.」が二つ出ているので既存のテストはパスし
ていることが確認できる。

=== stack_pop()の実装

まず、src/stack.hにstack_pop()の宣言を追加する。

src/stack.h:
  ...
  int    stack_pop      (Stack *stack);
  ...

つづいて、src/stack.cにstack_pop()の実装を追加する。

src/stack.c:
  ...
  int
  stack_pop (Stack *stack)
  {
      return 30;
  }

ここで30を返すようにしているのは最初のstack_pop()では30を返
すことが期待されているからである。

test/test-stack.c:49:
  cut_assert_equal_int(30, stack_pop(stack));

テストを実行し、popのテストもエラーが発生せずに実行されるこ
とを確認する。

  [stack]% test/run-test.sh
  ..F

  1) Failure: test_pop
  <2 == stack_get_size(stack)>
  expected: <2>
   but was: <3>
  test/test-stack.c:50: test_pop()

  Finished in 0.000085 seconds

  3 test(s), 6 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

popのテストが実行された。しかし、現在のstack_pop()ではスタッ
クサイズを変更していないため、popした後のスタックサイズを確
認しているtest/test-stack.cの50行目のstack_get_size()で失敗
している。

test/test-stack.c:50:
  cut_assert_equal_int(2, stack_get_size(stack));

=== データ領域の確保

テストが実行されることが確認できたのでテストにパスするように
stack_pop()を実装する。

後でpopで取り出すために、pushされたデータを保存しておく必要
がある。Stackに保存されたデータを示す場所を用意し、
stack_push()/stack_pop()で動的に必要な領域を割り当てる。

まず、Stackに保存されたデータを示す場所を用意し、stack_new()
で初期化、stack_free()で開放する。

src/stack.c:
  ...
  struct _Stack {
      int size;
      int *data;
  };

  Stack *
  stack_new (void)
  {
      ...
      stack->data = NULL;
      ...
  }

  void
  stack_free (Stack *stack)
  {
      free(stack->data);
      free(stack);
  }
  ...

この時点では外部向けの処理の内容は変わっていないはずなので、
テストを実行して変更前と同じように失敗することを確認する。

  [stack]% test/run-test.sh
  ..F

  1) Failure: test_pop
  <2 == stack_get_size(stack)>
  expected: <2>
   but was: <3>
  test/test-stack.c:50: test_pop()

  Finished in 0.000084 seconds

  3 test(s), 6 assertion(s), 1 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

=== stack_pop()の本実装

保存したデータを示す場所が用意できたので
stack_push()/stack_pop()でそこに必要な分だけ領域を割り当て、
データを保存する。

src/stack.c:
  ...
  void
  stack_push (Stack *stack, int value)
  {
      int *new_data;

      stack->size++;
      new_data = realloc(stack->data, sizeof(*stack->data) * stack->size);
      if (!new_data) {
          free(stack->data);
          stack->data = NULL;
          stack->size = 0;
          return;
      }
      stack->data = new_data;

      stack->data[stack->size - 1] = value;
  }

  int
  stack_pop (Stack *stack)
  {
      int value;
      int *new_data;

      stack->size--;
      value = stack->data[stack->size];

      new_data = realloc(stack->data, sizeof(*stack->data) * stack->size);
      if (stack->size > 0 && !new_data) {
          free(stack->data);
          stack->data = NULL;
          stack->size = 0;
          return value;
      }
      stack->data = new_data;

      return value;
  }

テストを実行し、popのテストがパスすることを確認する。

  [stack]% test/run-test.sh
  ...

  Finished in 0.000039 seconds

  3 test(s), 15 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

== 重複の排除

stack_push()/stack_pop()の実装では動的なメモリ割り当て部分、
メモリ割り当て失敗時のエラー処理部分に重複があった。一般的に
コード中に重複があることは、メンテナンス性の面などの理由で悪
いこととされている。

ここでは、既存の動作を変更せずに重複している悪い部分を修正す
る。既存の動作が変わっていないことはテストを実行することで確
認することができる。

=== メモリ割り当て部分の重複の除去

まず、以下のメモリ割り当て部分の重複を除去する。

src/stack.c:
  new_data = realloc(stack->data, sizeof(*stack->data) * stack->size);

この部分はstack_realloc()として切り出す。

src/stack.c:
  ...
  static int *
  stack_realloc (Stack *stack)
  {
      return realloc(stack->data, sizeof(*stack->data) * stack->size);
  }

  void
  stack_push (Stack *stack, int value)
  {
      ...
      new_data = stack_realloc(stack);
      ...
  }

  int
  stack_pop (Stack *stack)
  {
      ...
      new_data = stack_realloc(stack);
      ...
  }

この変更の後でも以前と同じ挙動をしているかを確かめる。

  [stack]% test/run-test.sh
  ...

  Finished in 0.000039 seconds

  3 test(s), 15 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

結果が緑なので次へ進める。

=== エラー処理部分の重複の除去

次に、以下のメモリ割り当て失敗時のエラー処理部分の重複を除去
する。

src/stack.c:
  ...
  void
  stack_push (Stack *stack, int value)
  {
      ...
      new_data = stack_realloc(stack);
      if (!new_data) {
          free(stack->data);
          stack->data = NULL;
          stack->size = 0;
          return;
      }
      ...
  }

  int
  stack_pop (Stack *stack)
  {
      ...
      new_data = stack_realloc(stack);
      if (stack->size > 0 && !new_data) {
          free(stack->data);
          stack->data = NULL;
          stack->size = 0;
          return value;
      }
      ...
  }

これらのエラー処理をstack_realloc()の中に移動し、
stack_realloc()は割り当てたメモリを返すのではなく、新しくメ
モリを割り当てることに成功したかどうかを返すことにする。

src/stack.c:
  ...
  static int
  stack_realloc (Stack *stack)
  {
      int *new_data;

      new_data = realloc(stack->data, sizeof(*stack->data) * stack->size);
      if (stack->size > 0 && !new_data) {
          free(stack->data);
          stack->data = NULL;
          stack->size = 0;
          return FALSE;
      }
      stack->data = new_data;

      return TRUE;
  }

  void
  stack_push (Stack *stack, int value)
  {
      stack->size++;
      if (!stack_realloc(stack))
          return;
      stack->data[stack->size - 1] = value;
  }

  int
  stack_pop (Stack *stack)
  {
      int value;

      stack->size--;
      value = stack->data[stack->size];
      stack_realloc(stack);
      return value;
  }

この変更の後でも以前と同じ挙動をしているかを確かめる。

  [stack]% test/run-test.sh
  ...

  Finished in 0.000040 seconds

  3 test(s), 15 assertion(s), 0 failure(s), 0 error(s), 0 pending(s), 0 notification(s)

既存の動作を変更することなく、プログラム中の重複部分を取り除
き、プログラムを改良したことを確認できた。

== まとめ

本稿では小さなスタックの実装を例にしてGNUビルドシステムを用い
たビルド環境の構築方法・Cutterを用いたテストの作成方法・テス
トのあるプログラムでのプログラムの改良方法を示した。

=== メリット

GNUビルドシステムを用いることにより、ビルド環境の差異を吸収
することが比較的容易になる。これはプログラムの移植性を向上さ
せることにつながる。

Cutterを用いることにより、簡単にテストが書ける。既存のC言語用
テスティングフレームワークではテストを定義するために独自のマ
クロを用いたり、テストの定義とテストの登録を別々に行う必要が
あるなどテスト以外にも書かなければいけないことが多い。Cutter
はこの点を改善し、テスト定義のための独自のマクロを提供せず、
通常どおりに関数を定義するだけでテストを定義できるようにした。
明示的にテストを定義する必要もない。

本稿ではcut_assert()とcut_assert_equal_int()しか使用しなかっ
たが、cut_assert_equal_string()など期待値と実際の値を比較する
ための方法を多数用意している。これにより、テストプログラムの
ための比較方法を定義しなければいけない機会が減り、より簡潔に
テストプログラムを書けるようになる。

また、Cutterのテスト結果出力は必要のない情報はなるべく表示せ
ず、必要な情報はできるだけ多く提供する。これは必要な情報が埋
もれてしまうのを防ぎ、プログラムの修正を支援する。また、C言語
ではよくある異常終了時には、バックトレースの出力を試み、プロ
グラム修正のためのより多くの情報を提供する。

既存の機能を変更せずにプログラムの内部構造を改良することはメ
ンテナンス性を向上させるのに非常に役立つ。自動化されたテスト
を作成することにより、既存の機能が変更されていないことを容易
に確認できる。

また、新規に機能を追加する場合でも、自動化されたテストがあれ
ば、既存の機能を壊すことなく機能を追加していることを確認でき
る。自動化テストを用意することはメンテナンス面でも、新機能開
発面でも品質の高いプログラムを作成する上で有用である。

=== スタックの実装

最終的なプログラムは以下の通りである。このスタックは素朴な実
装であるため、エラーの通知方法やパフォーマンスのチューニング
などの課題が残っているが、テストが示している通りの基本的な機
能は実装されている。

src/stack.c:
  #include <stdlib.h>
  #include "stack.h"

  #define TRUE 1
  #define FALSE 0

  struct _Stack {
      int size;
      int *data;
  };

  Stack *
  stack_new (void)
  {
      Stack *stack;

      stack = malloc(sizeof(Stack));
      if (!stack)
          return NULL;

      stack->size = 0;
      stack->data = NULL;
      return stack;
  }

  void
  stack_free (Stack *stack)
  {
      free(stack->data);
      free(stack);
  }

  int
  stack_is_empty (Stack *stack)
  {
      return stack->size == 0;
  }

  int
  stack_get_size (Stack *stack)
  {
      return stack->size;
  }

  static int
  stack_realloc (Stack *stack)
  {
      int *new_data;

      new_data = realloc(stack->data, sizeof(*stack->data) * stack->size);
      if (stack->size > 0 && !new_data) {
          free(stack->data);
          stack->data = NULL;
          stack->size = 0;
          return FALSE;
      }
      stack->data = new_data;

      return TRUE;
  }

  void
  stack_push (Stack *stack, int value)
  {
      stack->size++;
      if (!stack_realloc(stack))
          return;
      stack->data[stack->size - 1] = value;
  }

  int
  stack_pop (Stack *stack)
  {
      int value;

      stack->size--;
      value = stack->data[stack->size];
      stack_realloc(stack);
      return value;
  }

=== 関連項目

  * xUnit: Cutterも属するassertXXXといった方法で結果を確認し
    ながらテストを書いていくテストの書き方をサポートするライ
    ブラリのこと。テスティングフレームワークとも呼ぶ。様々な
    言語で実装されている。
    * SUnit (Smalltalk)
    * JUnit (Java)
    * Test::Unit (Ruby)
    * PyUnit (Pytnon)
    * ...

  * エクストリーム・プログラミング（Extreme Programming, XP）:
    品質の高いプログラムを開発するための方法を集めたプログラ
    ミング方法。テストの作成も重要視している。

